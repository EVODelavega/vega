syntax = "proto3";

package vega;
option go_package = "code.vegaprotocol.io/vega/proto";

import "github.com/mwitkow/go-proto-validators/validator.proto";

// Side
//
// A side relates to the direction of an order submission, to Buy or Sell.
enum Side {
  // Default value, always invalid.
  SIDE_UNSPECIFIED = 0;
  // Buy order.
  SIDE_BUY = 1;
  // Sell order.
  SIDE_SELL = 2;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum Interval)
}

// Interval
//
// Represents a set of time intervals that are used when querying for candle-stick data.
enum Interval {
  // Default value, always invalid.
  INTERVAL_UNSPECIFIED = 0;
  // 1 minute.
  INTERVAL_I1M = 60;
  // 5 minutes.
  INTERVAL_I5M = 300;
  // 15 minutes.
  INTERVAL_I15M = 900;
  // 1 hour.
  INTERVAL_I1H = 3600;
  // 6 hours.
  INTERVAL_I6H = 21600;
  // 1 day.
  INTERVAL_I1D = 86400;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum Interval)
}

// Price
//
message Price {
  // Price value, given as an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  uint64 value = 1;
}

// Timestamp
//
// A timestamp in nanoseconds since epoch.
// See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
message Timestamp {
  // Timestamp value.
  int64 value = 1;
}

// Party
//
// A party represents an entity who wishes to trade on or query a Vega network.
message Party {
  // A unique identifier for the party, typically represented by a public key.
  string id = 1 [(validator.field) = {msg_exists : true}];
}

// Risk Factor
//
// Risk factors are used to calculate the current risk associated with orders trading on a given market.
message RiskFactor {
  // Market ID that relates to this risk factor.
  string market = 1;
  // Short Risk factor value.
  double short = 2;
  // Long Risk factor value.
  double long = 3;
}

// Risk Result
//
// Risk results are calculated internally by Vega to attempt to maintain safe trading.
message RiskResult {
  // Timestamp for when risk factors were generated.
  int64 updatedTimestamp = 1;
  // Risk factors (long and short) for each margin-able asset/currency (usually == settlement assets) in the market.
  map<string, RiskFactor> riskFactors = 2;
  // Timestamp for when risk factors are expected to change (or empty if risk factors are continually updated).
  int64 nextUpdateTimestamp = 3;
  // Predicted risk factors at next change (what they would be if the change occurred now).
  map<string, RiskFactor> predictedNextRiskFactors = 4;
}

// Market Status
//
// What mode is the market currently running.
enum MarketState {
  // Default value, this is invalid
  MARKET_STATE_UNSPECIFIED = 0;
  // Normal trading
  MARKET_STATE_CONTINUOUS = 1;
  // Auction trading
  MARKET_STATE_AUCTION = 2;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum MarketState)
}

// Order
//
// An order can be submitted, amended and cancelled on Vega in an attempt to make trades with other parties.
message Order {

  // Time in Force for an order.
  //
  // See [What order types are available to trade on Vega?](https://docs.vega.xyz/docs/trading-questions/#what-order-types-are-available-to-trade-on-vega) for more detail.
  enum TimeInForce {
    // Default value for TimeInForce, can be valid for an amend.
    TIF_UNSPECIFIED = 0;
    // Good until cancelled.
    TIF_GTC = 1;
    // Good until specified time.
    TIF_GTT = 2;
    // Immediate or cancel.
    TIF_IOC = 3;
    // Fill or kill.
    TIF_FOK = 4;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderTimeInForce)
  }

  // Type values for an order.
  //
  enum Type {
    // Default value, always invalid.
    TYPE_UNSPECIFIED = 0;
    // Used for Limit orders.
    TYPE_LIMIT = 1;
    // Used for Market orders.
    TYPE_MARKET = 2;
    // Used for orders where the initiating party is the network (with distressed traders).
    TYPE_NETWORK = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderType)
  }

  // Status values for an order.
  //
  // See resulting status in [What order types are available to trade on Vega?](https://docs.vega.xyz/docs/trading-questions/#what-order-types-are-available-to-trade-on-vega) for more detail.
  enum Status {
    // Default value, always invalid.
    STATUS_INVALID = 0;
    // Used for active unfilled or partially filled orders.
    STATUS_ACTIVE = 1;
    // Used for expired GTT orders.
    STATUS_EXPIRED = 2;
    // Used for orders cancelled by the party that created the order.
    STATUS_CANCELLED = 3;
    // Used for unfilled FOK or IOC orders, and for orders that were stopped by the network.
    STATUS_STOPPED = 4;
    // Used for closed fully filled orders.
    STATUS_FILLED = 5;
    // Used for orders when not enough collateral was available to fill the margin requirements.
    STATUS_REJECTED = 6;
    // Used for closed partially filled IOC orders.
    STATUS_PARTIALLY_FILLED = 7;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderStatus)
  }

  // Good For values for an order.
  //
  // Specifies what market state can this order be accepted in.
  enum GoodFor {
    // Default value, always invalid.
    GOOD_FOR_UNSPECIFIED = 0;
    // Normal trading market.
    GOOD_FOR_CONTINUOUS = 1;
    // Auction.
    GOOD_FOR_AUCTION = 2;
    // Used for orders where the initiating party is the network (used for distressed traders)
    GOOD_FOR_AUCTION_AND_CONTINUOUS = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum GoodFor)
  }

  // Unique identifier for the order (set by the system after consensus).
  string id = 1;
  // Market identifier for the order.
  string marketID = 2;
  // Party identifier for the order.
  string partyID = 3;
  // Side for the order, e.g. SIDE_BUY or SIDE_SELL. See [`Side`](#vega.Side).
  Side side = 4;
  // Price for the order, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  uint64 price = 5;
  // Size for the order, for example, in a futures market the size equals the number of contracts.
  uint64 size = 6;
  // Size remaining, when this reaches 0 then the order is fully filled and status becomes STATUS_FILLED.
  uint64 remaining = 7;
  // Time in force indicates how long an order will remain active before it is executed or expires.
  // See [`Order.TimeInForce`](#vega.Order.TimeInForce).
  TimeInForce timeInForce = 8;
  // Type for the order. See [`Order.Type`](#vega.Order.Type).
  Type type = 9;
  // Timestamp for when the order was created at, in nanoseconds since the epoch.
  // See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
  int64 createdAt = 10;
  // The current status for the order. See [`Order.Status`](#vega.Order.Status).
  // For detail on `STATUS_REJECTED` please check the [`OrderError`](#vega.OrderError) value given in the `reason` field.
  Status status = 11;
  // Timestamp for when the order will expire, in nanoseconds since the epoch.
  // See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`. Valid only for [`Order.TimeInForce`](#vega.Order.TimeInForce)`.TIF_GTT`.
  int64 expiresAt = 12;
  // Reference given for the order, this is typically used to retrieve an order submitted through consensus.
  // TODO(cdm): Section on how order references work on Vega in docs.vega.xyz
  string reference = 13;
  // If the Order `status` is `STATUS_REJECTED` then an [`OrderError`](#vega.OrderError) reason will be specified.
  // The default for this field is `ORDER_ERROR_NONE` which signifies that there were no errors.
  OrderError reason = 14;
  // Timestamp for when the Order was last updated, in nanoseconds since the epoch.
  // See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
  int64 updatedAt = 15;
  // The version for the order, initial value is version 1 and is incremented after each successful amend
  uint64 version = 16;
  // Batch identifier for the order, used internally for orders submitted during auctions
  // to keep track of the auction batch this order falls under (required for fees calculation).
  uint64 batchID = 17;
  // Used to indicate which market state the order is good for.
  GoodFor goodFor = 18;
}

// Order Cancellation Confirmation
//
// Used when cancelling an Order.
message OrderCancellationConfirmation {
  // The order that was cancelled.
  Order order = 1;
}

// Order Confirmation
//
// Used when confirming an Order.
message OrderConfirmation {
  // The order that was confirmed.
  Order order = 1;
  // 0 or more trades that were emitted.
  repeated Trade trades = 2;
  // 0 or more passive orders that were affected.
  repeated Order passiveOrdersAffected = 3;
}

// Auction Indicative State
//
// Whenever a change to the book occurs during an auction, this message will be used
// to emit an event with the indicative price/volume per market
message AuctionIndicativeState {
  // The market identifier for which this state relates to.
  string marketID = 1;
  // The Indicative Uncrossing Price is the price at which all trades would occur if we uncrossed the auction now.
  uint64 indicativePrice = 2;
  // The Indicative Uncrossing Volume is the volume available at the Indicative crossing price if we uncrossed the auction now.
  uint64 indicativeVolume = 3;
  // The timestamp at which the auction started.
  int64 auctionStart = 4;
  // The timestamp at which the auction is meant to stop.
  int64 auctionEnd = 5;
}

// Order Error
//
// If there is an issue with an order during it's life-cycle, it will be marked with `status.ORDER_STATUS_REJECTED`
// and be given an error code in the `reason` field.
enum OrderError {
  // Default value, no error reported.
  ORDER_ERROR_NONE = 0;
  // Order was submitted for a market that does not exist.
  ORDER_ERROR_INVALID_MARKET_ID = 1;
  // Order was submitted with an invalid identifier.
  ORDER_ERROR_INVALID_ORDER_ID = 2;
  // Order was amended with a sequence number that was not previous version + 1.
  ORDER_ERROR_OUT_OF_SEQUENCE = 3;
  // Order was amended with an invalid remaining size (e.g. remaining greater than total size).
  ORDER_ERROR_INVALID_REMAINING_SIZE = 4;
  // Node was unable to get Vega (blockchain) time.
  ORDER_ERROR_TIME_FAILURE = 5;
  // Failed to remove an order from the book.
  ORDER_ERROR_REMOVAL_FAILURE = 6;
  // An order with `TimeInForce.TIF_GTT` was submitted or amended
  // with an expiration that was badly formatted or otherwise invalid.
  ORDER_ERROR_INVALID_EXPIRATION_DATETIME = 7;
  // Order was submitted or amended with an invalid reference field.
  ORDER_ERROR_INVALID_ORDER_REFERENCE = 8;
  // Order amend was submitted for an order field that cannot not be amended (e.g. order identifier).
  ORDER_ERROR_EDIT_NOT_ALLOWED = 9;
  // Amend failure because amend details do not match original order.
  ORDER_ERROR_AMEND_FAILURE = 10;
  // Order not found in an order book or store.
  ORDER_ERROR_NOT_FOUND = 11;
  // Order was submitted with an invalid or missing party identifier.
  ORDER_ERROR_INVALID_PARTY_ID = 12;
  // Order was submitted for a market that has closed.
  ORDER_ERROR_MARKET_CLOSED = 13;
  // Order was submitted, but the party did not have enough collateral to cover the order.
  ORDER_ERROR_MARGIN_CHECK_FAILED = 14;
  // Order was submitted, but the party did not have an account for this asset.
  ORDER_ERROR_MISSING_GENERAL_ACCOUNT = 15;
  // Unspecified internal error.
  ORDER_ERROR_INTERNAL_ERROR = 16;
  // Order was submitted with an invalid or missing size (e.g. 0).
  ORDER_ERROR_INVALID_SIZE = 17;
  // Order was submitted with an invalid persistence for its type.
  ORDER_ERROR_INVALID_PERSISTENCE = 18;
  // Order was submitted with an invalid type field.
  ORDER_ERROR_INVALID_TYPE = 19;
  // Order was stopped as it would have traded with another order submitted from the same party.
  ORDER_ERROR_SELF_TRADING = 20;
  // Order was submitted, but the party did not have enough collateral to cover the fees for the order.
  ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES = 21;
  // Order was submitted with an incorrect or invalid market type.
  ORDER_ERROR_INCORRECT_MARKET_TYPE = 22;

  // Note: If adding an enum value, add a matching entry in:
  //       - proto/errors.go (func Error)
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum RejectionReason)
}

// Trade
//
// A trade occurs when an aggressive order crosses one or more passive orders on the order book for a market on Vega.
message Trade {

  // Type values for a trade.
  //
  enum Type {
    // Default value, always invalid.
    TYPE_UNSPECIFIED = 0;
    // Normal trading between two parties.
    TYPE_DEFAULT = 1;
    // Trading initiated by the network with another party on the book,
    // which helps to zero-out the positions of one or more distressed parties.
    TYPE_NETWORK_CLOSE_OUT_GOOD = 2;
    // Trading initiated by the network with another party off the book,
    // with a distressed party in order to zero-out the position of the party.
    // todo(cdm): chat with Jeremy on zoom to sanity check/improve.
    TYPE_NETWORK_CLOSE_OUT_BAD = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum TradeType)
  }

  // Unique identifier for the trade (generated by Vega).
  string id = 1;
  // Market identifier (the market that the trade occurred on).
  string marketID = 2;
  // Price for the trade, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  uint64 price = 3;
  // Size filled for the trade.
  uint64 size = 4;
  // Unique party identifier for the buyer.
  string buyer = 5;
  // Unique party identifier for the seller.
  string seller = 6;
  // Direction of the aggressive party e.g. SIDE_BUY or SIDE_SELL. See [`Side`](#vega.Side).
  Side aggressor = 7;
  // Identifier of the order from the buy side.
  string buyOrder = 8;
  // Identifier of the order from the sell side.
  string sellOrder = 9;
  // Timestamp for when the trade occurred, in nanoseconds since the epoch.
  // See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
  int64 timestamp = 10;
  // Type for the trade. See [`Trade.Type`](#vega.Trade.Type).
  Type type = 11;
  // Fee amount charged to the buyer party for the trade.
  Fee buyerFee = 12;
  // Fee amount charged to the seller party for the trade.
  Fee sellerFee = 13;
  // Auction batch number that the buy side order was placed in.
  uint64 buyerAuctionBatch = 14;
  // Auction batch number that the sell side order was placed in.
  uint64 sellerAuctionBatch = 15;
}

// Fee
//
// Represents any fees paid by a party, resulting from a trade.
message Fee {
  // Fee amount paid to the non-aggressive party of the trade.
  uint64 makerFee = 1;
  // Fee amount paid for maintaining the Vega infrastructure.
  uint64 infrastructureFee = 2;
  // Fee amount paid to market makers.
  uint64 liquidityFee = 3;
}

// TradeSet
//
// A set of one or more trades.
message TradeSet {
    repeated Trade trades = 1;
}

// Candle
//
// Represents the high, low, open, and closing prices for an interval of trading,
// referred to commonly as a candlestick or candle.
message Candle {
  // Timestamp for when the candle was last updated, in nanoseconds since the epoch.
  // See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
  int64 timestamp = 1;
  // An ISO 8601 datetime with nanosecond precision for when the candle was last updated.
  string datetime = 2;
  // Highest price for trading during the candle interval.
  uint64 high = 3;
  // Lowest price for trading during the candle interval.
  uint64 low = 4;
  // Open trade price.
  uint64 open = 5;
  // Closing trade price.
  uint64 close = 6;
  // Total trading volume during the candle interval.
  uint64 volume = 7;
  // Time interval for the candle. See [`Interval`](#vega.Interval).
  Interval interval = 8;
}

// Price Level
//
// Represents a price level from market depth or order book data.
message PriceLevel {
  // Price for the price level, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  uint64 price = 1;
  // Number of orders at the price level.
  uint64 numberOfOrders = 2;
  // Volume at the price level.
  uint64 volume = 3;
  // Cumulative volume at the price level.
  uint64 cumulativeVolume = 4;
}

// Market Depth
//
// Represents market depth or order book data for the specified market on Vega.
message MarketDepth {
  // Market identifier.
  string marketID = 1;
  // Collection of price levels for the buy side of the book.
  repeated PriceLevel buy = 2;
  // Collection of price levels for the sell side of the book.
  repeated PriceLevel sell = 3;
}

// Position
//
// Represents position data for a party on the specified market on Vega.
message Position {
  // Market identifier.
  string marketID = 1;
  // Party identifier.
  string partyID = 2;
  // Open volume for the position. Value is signed +ve for long and -ve for short.
  int64 openVolume = 3;
  // Realised profit and loss for the position. Value is signed +ve for long and -ve for short.
  int64 realisedPNL  = 4;
  // Unrealised profit and loss for the position. Value is signed +ve for long and -ve for short.
  int64 unrealisedPNL = 5;
  // Average entry price for the position, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  uint64 averageEntryPrice = 6;
}

// Position Trade
//
message PositionTrade {
  // Volume for the position trade. Value is signed +ve for long and -ve for short.
  int64 volume = 1;
  // Price for the position trade, the price is an integer, for example `123456` is a correctly
  // formatted price of `1.23456` assuming market configured to 5 decimal places.
  uint64 price = 2;
}

// Statistics
//
// Vega domain specific statistics as reported by the node the caller is connected to.
message Statistics {
  uint64 blockHeight = 1;
  uint64 backlogLength = 2;
  uint64 totalPeers = 3;

  // ISO 8601 datetime, nanosecond precision
  string genesisTime = 4;

  // ISO 8601 datetime, nanosecond precision
  string currentTime = 5;

  // ISO 8601 datetime, nanosecond precision
  string vegaTime = 6;

  ChainStatus status = 7;
  uint64 txPerBlock = 8;
  uint64 averageTxBytes = 9;
  uint64 averageOrdersPerBlock = 10;
  uint64 tradesPerSecond = 11;
  uint64 ordersPerSecond = 12;
  uint64 totalMarkets = 13;
  uint64 totalAmendOrder = 16;
  uint64 totalCancelOrder = 17;
  uint64 totalCreateOrder = 18;
  uint64 totalOrders = 19;
  uint64 totalTrades = 20;
  uint32 orderSubscriptions = 21;
  uint32 tradeSubscriptions = 22;
  uint32 candleSubscriptions = 23;
  uint32 marketDepthSubscriptions = 24;
  uint32 positionsSubscriptions = 25;
  uint32 accountSubscriptions = 26;
  uint32 marketDataSubscriptions = 27;
  string appVersionHash = 28;
  string appVersion = 29;
  string chainVersion = 30;

  // nanoseconds
  uint64 blockDuration = 31;

  // ISO 8601 datetime, nanosecond precision
  string uptime = 32;

  // Unique ID of the blockchain
  string chainID = 33;
}

// Blockchain Status
//
// The blockchain status as reported by the node the caller is connected to.
enum ChainStatus {
  // Default value, always invalid.
  CHAIN_STATUS_UNSPECIFIED = 0;
  // Blockchain is disconnected.
  CHAIN_STATUS_DISCONNECTED = 1;
  // Blockchain is replaying historic transactions.
  CHAIN_STATUS_REPLAYING = 2;
  // Blockchain is connected and receiving transactions.
  CHAIN_STATUS_CONNECTED = 3;

  // Note: ChainStatus does not exist in GraphQL.
}

message NotifyTraderAccount {
  string traderID = 1;
  uint64 amount = 2;
}

message Withdraw {
  string partyID = 1;
  uint64 amount = 2;
  string asset = 3;
}

message OrderAmendment {
  // required to find the order, not being updated
  string orderID = 1 [(validator.field) = {string_not_empty : true}];
  string partyID = 2 [(validator.field) = {string_not_empty: true}];
  string marketID = 3;

  // these can be amended
  Price price = 4;
  int64 sizeDelta = 5;
  Timestamp expiresAt = 6;
  Order.TimeInForce timeInForce = 7;
}

message OrderSubmission {
  string id = 1 [(validator.field) = {string_not_empty: false}];
  string marketID = 2 [(validator.field) = {string_not_empty: true}];
  string partyID = 3 [(validator.field) = {string_not_empty: true}];
  uint64 price = 4; // mandatory for Limit orders, not required for Market orders
  uint64 size = 5 [(validator.field) = {int_gt: 0}];
  Side side = 6 [(validator.field) = {is_in_enum: true}];
  Order.TimeInForce timeInForce = 7 [(validator.field) = {is_in_enum: true}];
  int64 expiresAt = 8; // mandatory for GTT orders, not required for GTC, IOC, FOK
  Order.Type type = 9 [(validator.field) = {is_in_enum : true}];
  string reference = 10;
  Order.GoodFor goodFor = 11 [(validator.field) = {is_in_enum : true}];
}

message OrderCancellation {
  string orderID = 1 [(validator.field) = {string_not_empty: true}];
  string marketID = 2 [(validator.field) = {string_not_empty: true}];
  string partyID = 3 [(validator.field) = {string_not_empty: true}];
}

message NodeRegistration {
  bytes pubKey = 1 [(validator.field) = {string_not_empty: true}];
  bytes chainPubKey = 2 [(validator.field) = {string_not_empty: true}];
}

message NodeVote {
  bytes pubKey = 1 [(validator.field) = {string_not_empty: true}];
  string reference = 2 [(validator.field) = {string_not_empty: true}];
}

enum AccountType {
  // the default variant for this enum
  ACCOUNT_TYPE_UNSPECIFIED = 0;
  // This account is created to hold the insurance pool funds of a market.
  ACCOUNT_TYPE_INSURANCE = 1;
  // This account is created to hold fund while settlement or mtm occur.
  ACCOUNT_TYPE_SETTLEMENT = 2;
  // A party will have multiple margin accounts, one for each market they have traded in. The balance will shift as margin requirements on positions change
  ACCOUNT_TYPE_MARGIN = 3;
  // A party will have multiple general accounts, one for each assets they want
  // to trade with. This is the account where the funds are initially deposited
  // or withdrawn from. It's also the account where funds are taken to fullfill
  // margin requirement or fees
  ACCOUNT_TYPE_GENERAL = 4;
  //This account is created to hold fees earned for providing infrastructure
  ACCOUNT_TYPE_FEES_INFRASTRUCTURE = 5;
  // This account is created to hold fees earned for providing liquidity
  ACCOUNT_TYPE_FEES_LIQUIDITY = 6;
  // This account is created to hold fees earned for placing orders that sit on the book
  ACCOUNT_TYPE_FEES_MAKER = 7;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum AccountType)
}

message Account {
  string id = 1;
  string owner = 2;
  uint64 balance = 3;
  string asset = 4;
  string marketID = 5;
  AccountType type = 6;
}

message FinancialAmount {
  int64 amount = 1;
  string asset = 2;
}

enum TransferType {
  TRANSFER_TYPE_UNSPECIFIED = 0;
  TRANSFER_TYPE_LOSS = 1;
  TRANSFER_TYPE_WIN = 2;
  TRANSFER_TYPE_CLOSE = 3;
  TRANSFER_TYPE_MTM_LOSS = 4;
  TRANSFER_TYPE_MTM_WIN = 5;
  TRANSFER_TYPE_MARGIN_LOW = 6;
  TRANSFER_TYPE_MARGIN_HIGH = 7;
  TRANSFER_TYPE_MARGIN_CONFISCATED = 8;
  TRANSFER_TYPE_MAKER_FEE_PAY = 9;
  TRANSFER_TYPE_MAKER_FEE_RECEIVE = 10;
  TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY = 11;
  TRANSFER_TYPE_LIQUIDITY_FEE_PAY = 12;
}

message Transfer {
  string owner = 1;
  FinancialAmount amount = 2;
  TransferType type = 3;
  int64 minAmount = 4;
}

message TransferRequest {
  repeated Account fromAccount = 1;
  repeated Account toAccount = 2;
  uint64 amount = 3;
  uint64 minAmount = 4;
  string asset = 5;
  string reference = 6;
}

message LedgerEntry {
  string fromAccount = 1;
  string toAccount = 2;
  uint64 amount = 3;
  string reference = 4;
  string type = 5;
  int64 timestamp = 6;
}

message TransferBalance {
  Account account = 1;
  uint64 balance = 2;
}

message TransferResponse {
  repeated LedgerEntry transfers = 1;
  repeated TransferBalance balances = 2;
}

message MarginLevels {
  uint64 maintenanceMargin = 1;
  uint64 searchLevel = 2;
  uint64 initialMargin = 3;
  uint64 collateralReleaseLevel = 4;
  string partyID = 5;
  string marketID = 6;
  string asset = 7;
  int64 timestamp = 8;
}

message MarketData {
  // the mark price (actually an unsgined int)
  uint64 markPrice = 1;
  // the highest price level on an order book for buy orders.
  uint64 bestBidPrice = 2;
  // the aggregated volume being bid at the best bid price.
  uint64 bestBidVolume = 3;
  // the lowest price level on an order book for offer orders.
  uint64 bestOfferPrice = 4;
  // the aggregated volume being offered at the best offer price.
  uint64 bestOfferVolume = 5;
  // the arithmetic average of the best bid price and best offer price.
  uint64 midPrice = 6;
  // market id of the associated mark price
  string market = 7;
  // time at which this mark price was relevant
  int64 timestamp = 8;
  // the sum of the size of all positions greater than 0.
  uint64 openInterest = 9;
  // time in seconds until the end of the auction (0 if currently not in auction period)
  int64 auctionEnd = 10;
  // time until next auction (used in FBA's) - currently always 0
  int64 auctionStart = 11;
}

message ErrorDetail {
  // a Vega API domain specific unique error code, useful for client side mappings. e.g. 10004
  int32 code = 1;
  // a message that describes the error in more detail, should describe the problem encountered.
  string message = 2;
  // any inner error information that could add more context, or be helpful for error reporting.
  string inner = 3;
}

// A transaction to be sent to vega
message Transaction {
  // one of all the possible command, proto marshalled
  bytes inputData = 1;
  // a random number used to provided uniqueness and prevents
  // against replay attack
  uint64 nonce = 2;
  // the sender of the transction
  // any of the following would be valid
  oneof from {
    // the address of the sender
    bytes address = 1001;
    // the public key of the sender
    bytes pubKey = 1002;
  }
}

// A signature to be authenticate a transaction
// and to be verified by the vega network
message Signature {
  // The bytes of the signature
  bytes sig = 1;
  // The algorithm used to create the signature
  string algo = 2;
  // The version of the signature used to create the signature
  uint64 version = 3;
}


// A bundle of a transaction, proto marshalled and it's signature
message SignedBundle {
  // the transaction, proto marshalled
  bytes tx = 1;
  // the signature authenticating the transaction
  Signature sig = 2;
}


// The kind of the signature created by a node
// eg: for a new asset whitelisting, withdrawal
enum NodeSignatureKind {
  // represents a unspecified / missing value from the input
  NODE_SIGNATURE_KIND_UNSPECIFIED = 0;
  // represents a signature for a new asset whitelisting
  NODE_SIGNATURE_KIND_ASSET_NEW = 1;
  // represents a signature for a asset withdrawal
  NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL = 2;
}

// A message reprensenting a signature from a validator
// meant to be used by foreign chain in order to recognise
// a decision taken by the vega network.
message NodeSignature {
  // The ID of the resource being signed
  string ID = 1;
  // The signature
  bytes sig = 2;
  // The kind of resource being signed
  NodeSignatureKind kind = 3;
}
