syntax = "proto3";

package vega;
option go_package = "code.vegaprotocol.io/vega/proto";

import "github.com/mwitkow/go-proto-validators/validator.proto";

enum Side {
  // Default value, always invalid
  SIDE_UNSPECIFIED = 0;

  // Buy
  SIDE_BUY = 1;

  // Sell
  SIDE_SELL = 2;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum Interval)
}

enum Interval {

  // Default value, always invalid
  INTERVAL_UNSPECIFIED = 0;

  // 1 minute
  INTERVAL_I1M = 60;

  // 5 minutes
  INTERVAL_I5M = 300;

  // 15 minutes
  INTERVAL_I15M = 900;

  // 1 hour
  INTERVAL_I1H = 3600;

  // 6 hours
  INTERVAL_I6H = 21600;

  // 1 day
  INTERVAL_I1D = 86400;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum Interval)
}

message Price {
  uint64 value = 1;
}

message Timestamp {
  int64 value = 1;
}

message Party {
  string id = 1 [(validator.field) = {msg_exists : true}];
}

message RiskFactor {
  string market = 1;
  double short = 2;
  double long = 3;
}

message RiskResult {
  // timestamp when these risk factors were generated
  int64 updatedTimestamp = 1;
  // risk factors (long and short) for each marginable asset/currency (usually == settlement assets) in the market
  map<string, RiskFactor> riskFactors = 2;
  // time when risk factors are expected to change (or empty if risk factors are continually updated)
  int64 nextUpdateTimestamp = 3;
  // predicted risk factors at next change (what they'd be if the change occurred now)
  map<string, RiskFactor> predictedNextRiskFactors = 4;
}

message Order {

  // Order Time in Force
  //
  // See [What order types are available to trade on Vega?](https://docs.vega.xyz/docs/50-trading-questions/#what-order-types-are-available-to-trade-on-vega) for details.
  enum TimeInForce {
    // Default value, can be valid for an amend
    TIF_UNSPECIFIED = 0;

    // good til cancelled
    TIF_GTC = 1;

    // good til time
    TIF_GTT = 2;

    // immediate or cancel
    TIF_IOC = 3;

    // fill or kill
    TIF_FOK = 4;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderTimeInForce)
  }

  // Order Type
  enum Type {
    // Default value, always invalid
    TYPE_UNSPECIFIED = 0;

    // used for Limit orders
    TYPE_LIMIT = 1;

    // used for Market orders
    TYPE_MARKET = 2;

    // used for orders where the initiating party is the network (used for distressed traders)
    TYPE_NETWORK = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderType)
  }

  // Order Status
  //
  // See [What order types are available to trade on Vega?](https://docs.vega.xyz/docs/50-trading-questions/#what-order-types-are-available-to-trade-on-vega) for details.
  enum Status {
    // Default value, always invalid
    STATUS_INVALID = 0;

    // used for active unfilled or partially filled orders
    STATUS_ACTIVE = 1;

    // used for expired GTT orders
    STATUS_EXPIRED = 2;

    // used for orders cancelled by the party that created the order
    STATUS_CANCELLED = 3;

    // used for unfilled FOK or IOC orders, and for orders that were stopped by the network
    STATUS_STOPPED = 4;

    // used for closed fully filled orders
    STATUS_FILLED = 5;

    // used for orders when not enough collateral was available to fill the margin requirements
    STATUS_REJECTED = 6;

    // used for closed partially filled IOC orders
    STATUS_PARTIALLY_FILLED = 7;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum OrderStatus)
  }

  string id = 1;
  string marketID = 2;
  string partyID = 3;
  Side side = 4;
  uint64 price = 5;
  uint64 size = 6;
  uint64 remaining = 7;
  TimeInForce timeInForce = 8;
  Type type = 9;

  // nanoseconds since the epoch. See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
  int64 createdAt = 10;

  // If `status` is `STATUS_REJECTED`, check `reason`.
  Status status = 11;

  int64 expiresAt = 12;
  string reference = 13;
  OrderError reason = 14;
  int64 updatedAt = 15;

  // Versioning support for amends, orders start at version 1 and increment
  // after each successful amend
  uint64 version = 16;

  // used internally, for orders submitted during auctions
  // to keep track which auction batch this order falls under (required for fees calculation)
  uint64 batchID = 17;
}

message OrderCancellationConfirmation {
    Order order = 1;
}

message OrderConfirmation {
    Order order = 1;
    repeated Trade trades = 2;
    repeated Order passiveOrdersAffected = 3;
}

// Whenever a change to the book occurs during an auction, this message will be used
// to emit an event with the indicative price/volume per market
message AuctionIndicativeState {
  // The market this state is related to
  string marketID = 1;
  // The Indicative Uncrossing Price is the price at which all trades would occur if we uncrossed the auction now.
  uint64 indicativePrice = 2;
  // The Indicative Uncrossing Volume is the volume available at the Indicative crossing price if we uncrossed the auction now.
  uint64 indicativeVolume = 3;
  // The timestamp at which the auction started
  int64 auctionStart = 4;
  // The timestamp at which the auction is meant to stop.
  int64 auctionEnd = 5;
}

// Set when an order has an issue
enum OrderError {
  // Empty default error
  ORDER_ERROR_NONE = 0;

  // Order was submitted for a market that does not exist
  ORDER_ERROR_INVALID_MARKET_ID = 1;

  // Order was submitted with an invalid ID
  ORDER_ERROR_INVALID_ORDER_ID = 2;

  // Order was amended with a sequence number that was not previous version + 1
  ORDER_ERROR_OUT_OF_SEQUENCE = 3;

  // Order was amended with an invalid remaining size (e.g. remaining greater than total size)
  ORDER_ERROR_INVALID_REMAINING_SIZE = 4;

  // Node was unable to get Vega (blockchain) time
  ORDER_ERROR_TIME_FAILURE = 5;

  // Failed to remove an order from the book
  ORDER_ERROR_REMOVAL_FAILURE = 6;

  // GTT Order submitted or amended with an expiration that was badly formatted or otherwise invalid
  ORDER_ERROR_INVALID_EXPIRATION_DATETIME = 7;

  // Order was submitted or amended with an invalid reference field
  ORDER_ERROR_INVALID_ORDER_REFERENCE = 8;

  // Order amend was submitted for an order field that cannot not be amended (e.g. order id)
  ORDER_ERROR_EDIT_NOT_ALLOWED = 9;

  // Amend failure because amend details do not match original order
  ORDER_ERROR_AMEND_FAILURE = 10;

  // Order not found in the order book or in order store
  ORDER_ERROR_NOT_FOUND = 11;

  // Order was submitted with an invalid or missing party ID
  ORDER_ERROR_INVALID_PARTY_ID = 12;

  // Order was submitted for a market that has closed
  ORDER_ERROR_MARKET_CLOSED = 13;

  // Order was submitted, but the party did not have enough collateral to cover the order
  ORDER_ERROR_MARGIN_CHECK_FAILED = 14;

  // Order was submitted, but the party did not have an account for this asset
  ORDER_ERROR_MISSING_GENERAL_ACCOUNT = 15;

  // Unspecified internal error
  ORDER_ERROR_INTERNAL_ERROR = 16;

  // Order was submitted with an invalid or missing size (e.g. 0)
  ORDER_ERROR_INVALID_SIZE = 17;

  // Order was submitted with an invalid persistence for its type
  ORDER_ERROR_INVALID_PERSISTENCE = 18;

  // Order was submitted with an invalid type field
  ORDER_ERROR_INVALID_TYPE = 19;

  // Order was stopped as it would have traded with another order for the same party
  ORDER_ERROR_SELF_TRADING = 20;

  // Order was submitted, but the party did not have enough collateral to cover the fees for the order
  ORDER_ERROR_INSUFFICIENT_FUNDS_TO_PAY_FEES = 21;

  // Note: If adding an enum value, add a matching entry in:
  //       - proto/errors.go (func Error)
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum RejectionReason)
}

message Trade {

  enum Type {
    // Default value, always invalid
    TYPE_UNSPECIFIED = 0;

    TYPE_DEFAULT = 1;
    TYPE_NETWORK_CLOSE_OUT_GOOD = 2;
    TYPE_NETWORK_CLOSE_OUT_BAD = 3;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum TradeType)
  }

  string id = 1;
  string marketID = 2;
  uint64 price = 3;
  uint64 size = 4;
  string buyer = 5;
  string seller = 6;
  Side aggressor = 7;
  string buyOrder = 8;
  string sellOrder = 9;

  // nanoseconds since the epoch. See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
  int64 timestamp = 10;
  Type type = 11;

  Fee buyerFee = 12;
  Fee sellerFee = 13;
  uint64 buyerAuctionBatch = 14;
  uint64 sellerAuctionBatch = 15;
}

// The fees being paid by a party, resulting from a trade
message Fee {
  // A fee being paid to the non-aggressor party of the trade
  uint64 makerFee = 1;
  // A fee being paid to maintaining the vega infrastructure
  uint64 infrastructureFee = 2;
  // A fee being paid to the market makers
  uint64 liquidityFee = 3;
}

message TradeSet {
    repeated Trade trades = 1;
}

message Candle {

    // nanoseconds since the epoch. See [`VegaTimeResponse`](#api.VegaTimeResponse).`timestamp`.
    int64 timestamp = 1;

    // ISO 8601 datetime
    string datetime = 2;

    uint64 high = 3;
    uint64 low = 4;
    uint64 open = 5;
    uint64 close = 6;
    uint64 volume = 7;
    Interval interval = 8;
}

message PriceLevel {
    uint64 price = 1;
    uint64 numberOfOrders = 2;
    uint64 volume = 3;
    uint64 cumulativeVolume = 4;
}

message MarketDepth {
    string marketID = 1;
    repeated PriceLevel buy = 2;
    repeated PriceLevel sell = 3;
}

message Position {
    string marketID = 1;
    string partyID = 2;
    int64 openVolume = 3;
    int64 realisedPNL  = 4;
    int64 unrealisedPNL = 5;
    uint64 averageEntryPrice = 6;
}

message PositionTrade {
  int64 volume = 1;
  uint64 price = 2;
}

message Statistics {
  uint64 blockHeight = 1;
  uint64 backlogLength = 2;
  uint64 totalPeers = 3;

  // ISO 8601 datetime, nanosecond precision
  string genesisTime = 4;

  // ISO 8601 datetime, nanosecond precision
  string currentTime = 5;

  // ISO 8601 datetime, nanosecond precision
  string vegaTime = 6;

  ChainStatus status = 7;
  uint64 txPerBlock = 8;
  uint64 averageTxBytes = 9;
  uint64 averageOrdersPerBlock = 10;
  uint64 tradesPerSecond = 11;
  uint64 ordersPerSecond = 12;
  uint64 totalMarkets = 13;
  uint64 totalAmendOrder = 16;
  uint64 totalCancelOrder = 17;
  uint64 totalCreateOrder = 18;
  uint64 totalOrders = 19;
  uint64 totalTrades = 20;
  uint32 orderSubscriptions = 21;
  uint32 tradeSubscriptions = 22;
  uint32 candleSubscriptions = 23;
  uint32 marketDepthSubscriptions = 24;
  uint32 positionsSubscriptions = 25;
  uint32 accountSubscriptions = 26;
  uint32 marketDataSubscriptions = 27;
  string appVersionHash = 28;
  string appVersion = 29;
  string chainVersion = 30;

  // nanoseconds
  uint64 blockDuration = 31;

  // ISO 8601 datetime, nanosecond precision
  string uptime = 32;

  // Unique ID of the blockchain
  string chainID = 33;
}

enum ChainStatus {
  CHAIN_STATUS_UNSPECIFIED = 0;
  CHAIN_STATUS_DISCONNECTED = 1;
  CHAIN_STATUS_REPLAYING = 2;
  CHAIN_STATUS_CONNECTED = 3;

  // Note: ChainStatus does not exist in GraphQL.
}

message NotifyTraderAccount {
  string traderID = 1;
  uint64 amount = 2;
}

message Withdraw {
  string partyID = 1;
  uint64 amount = 2;
  string asset = 3;
}

message OrderAmendment {
  // required to find the order, not being updated
  string orderID = 1 [(validator.field) = {string_not_empty : true}];
  string partyID = 2 [(validator.field) = {string_not_empty: true}];
  string marketID = 3;

  // these can be amended
  Price price = 4;
  int64 sizeDelta = 5;
  Timestamp expiresAt = 6;
  Order.TimeInForce timeInForce = 7;
}

message OrderSubmission {
  string id = 1 [(validator.field) = {string_not_empty: false}];
  string marketID = 2 [(validator.field) = {string_not_empty: true}];
  string partyID = 3 [(validator.field) = {string_not_empty: true}];
  uint64 price = 4; // mandatory for Limit orders, not required for Market orders
  uint64 size = 5 [(validator.field) = {int_gt: 0}];
  Side side = 6 [(validator.field) = {is_in_enum: true}];
  Order.TimeInForce timeInForce = 7 [(validator.field) = {is_in_enum: true}];
  int64 expiresAt = 8; // mandatory for GTT orders, not required for GTC, IOC, FOK
  Order.Type type = 9 [(validator.field) = {is_in_enum : true}];
  string reference = 10;
}

message OrderCancellation {
  string orderID = 1 [(validator.field) = {string_not_empty: true}];
  string marketID = 2 [(validator.field) = {string_not_empty: true}];
  string partyID = 3 [(validator.field) = {string_not_empty: true}];
}

message NodeRegistration {
  bytes pubKey = 1 [(validator.field) = {string_not_empty: true}];
  bytes chainPubKey = 2 [(validator.field) = {string_not_empty: true}];
}

message NodeVote {
  bytes pubKey = 1 [(validator.field) = {string_not_empty: true}];
  string reference = 2 [(validator.field) = {string_not_empty: true}];
}

enum AccountType {
  // the default variant for this enum
  ACCOUNT_TYPE_UNSPECIFIED = 0;
  // This account is created to hold the insurance pool funds of a market.
  ACCOUNT_TYPE_INSURANCE = 1;
  // This account is created to hold fund while settlement or mtm occur.
  ACCOUNT_TYPE_SETTLEMENT = 2;
  // A party will have multiple margin accounts, one for each market they have traded in. The balance will shift as margin requirements on positions change
  ACCOUNT_TYPE_MARGIN = 3;
  // A party will have multiple general accounts, one for each assets they want
  // to trade with. This is the account where the funds are initially deposited
  // or withdrawn from. It's also the account where funds are taken to fullfill
  // margin requirement or fees
  ACCOUNT_TYPE_GENERAL = 4;
  //This account is created to hold fees earned for providing infrastructure
  ACCOUNT_TYPE_FEES_INFRASTRUCTURE = 5;
  // This account is created to hold fees earned for providing liquidity
  ACCOUNT_TYPE_FEES_LIQUIDITY = 6;
  // This account is created to hold fees earned for placing orders that sit on the book
  ACCOUNT_TYPE_FEES_MAKER = 7;

  // Note: If adding an enum value, add a matching entry in:
  //       - gateway/graphql/helpers_enum.go
  //       - gateway/graphql/schema.graphql (enum AccountType)
}

message Account {
  string id = 1;
  string owner = 2;
  uint64 balance = 3;
  string asset = 4;
  string marketID = 5;
  AccountType type = 6;
}

message FinancialAmount {
  int64 amount = 1;
  string asset = 2;
}

enum TransferType {
  TRANSFER_TYPE_UNSPECIFIED = 0;
  TRANSFER_TYPE_LOSS = 1;
  TRANSFER_TYPE_WIN = 2;
  TRANSFER_TYPE_CLOSE = 3;
  TRANSFER_TYPE_MTM_LOSS = 4;
  TRANSFER_TYPE_MTM_WIN = 5;
  TRANSFER_TYPE_MARGIN_LOW = 6;
  TRANSFER_TYPE_MARGIN_HIGH = 7;
  TRANSFER_TYPE_MARGIN_CONFISCATED = 8;
  TRANSFER_TYPE_MAKER_FEE_PAY = 9;
  TRANSFER_TYPE_MAKER_FEE_RECEIVE = 10;
  TRANSFER_TYPE_INFRASTRUCTURE_FEE_PAY = 11;
  TRANSFER_TYPE_LIQUIDITY_FEE_PAY = 12;
}

message Transfer {
  string owner = 1;
  FinancialAmount amount = 2;
  TransferType type = 3;
  int64 minAmount = 4;
}

message TransferRequest {
  repeated Account fromAccount = 1;
  repeated Account toAccount = 2;
  uint64 amount = 3;
  uint64 minAmount = 4;
  string asset = 5;
  string reference = 6;
}

message LedgerEntry {
  string fromAccount = 1;
  string toAccount = 2;
  uint64 amount = 3;
  string reference = 4;
  string type = 5;
  int64 timestamp = 6;
}

message TransferBalance {
  Account account = 1;
  uint64 balance = 2;
}

message TransferResponse {
  repeated LedgerEntry transfers = 1;
  repeated TransferBalance balances = 2;
}

message MarginLevels {
  uint64 maintenanceMargin = 1;
  uint64 searchLevel = 2;
  uint64 initialMargin = 3;
  uint64 collateralReleaseLevel = 4;
  string partyID = 5;
  string marketID = 6;
  string asset = 7;
  int64 timestamp = 8;
}

message MarketData {
  // the mark price (actually an unsgined int)
  uint64 markPrice = 1;
  // the highest price level on an order book for buy orders.
  uint64 bestBidPrice = 2;
  // the aggregated volume being bid at the best bid price.
  uint64 bestBidVolume = 3;
  // the lowest price level on an order book for offer orders.
  uint64 bestOfferPrice = 4;
  // the aggregated volume being offered at the best offer price.
  uint64 bestOfferVolume = 5;
  // the arithmetic average of the best bid price and best offer price.
  uint64 midPrice = 6;
  // market id of the associated mark price
  string market = 7;
  // time at which this mark price was relevant
  int64 timestamp = 8;
  // the sum of the size of all positions greater than 0.
  uint64 openInterest = 9;
  // time in seconds until the end of the auction (0 if currently not in auction period)
  int64 auctionEnd = 10;
  // time until next auction (used in FBA's) - currently always 0
  int64 auctionStart = 11;
}

message ErrorDetail {
  // a Vega API domain specific unique error code, useful for client side mappings. e.g. 10004
  int32 code = 1;
  // a message that describes the error in more detail, should describe the problem encountered.
  string message = 2;
  // any inner error information that could add more context, or be helpful for error reporting.
  string inner = 3;
}

// A transaction to be sent to vega
message Transaction {
  // one of all the possible command, proto marshalled
  bytes inputData = 1;
  // a random number used to provided uniqueness and prevents
  // against replay attack
  uint64 nonce = 2;
  // the sender of the transction
  // any of the following would be valid
  oneof from {
    // the address of the sender
    bytes address = 1001;
    // the public key of the sender
    bytes pubKey = 1002;
  }
}

// A signature to be authenticate a transaction
// and to be verified by the vega network
message Signature {
  // The bytes of the signature
  bytes sig = 1;
  // The algorithm used to create the signature
  string algo = 2;
  // The version of the signature used to create the signature
  uint64 version = 3;
}


// A bundle of a transaction, proto marshalled and it's signature
message SignedBundle {
  // the transaction, proto marshalled
  bytes tx = 1;
  // the signature authenticating the transaction
  Signature sig = 2;
}


// The kind of the signature created by a node
// eg: for a new asset whitelisting, withdrawal
enum NodeSignatureKind {
  // represents a unspecified / missing value from the input
  NODE_SIGNATURE_KIND_UNSPECIFIED = 0;
  // represents a signature for a new asset whitelisting
  NODE_SIGNATURE_KIND_ASSET_NEW = 1;
  // represents a signature for a asset withdrawal
  NODE_SIGNATURE_KIND_ASSET_WITHDRAWAL = 2;
}

// A message reprensenting a signature from a validator
// meant to be used by foreign chain in order to recognise
// a decision taken by the vega network.
message NodeSignature {
  // The ID of the resource being signed
  string ID = 1;
  // The signature
  bytes sig = 2;
  // The kind of resource being signed
  NodeSignatureKind kind = 3;
}
