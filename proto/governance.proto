syntax = "proto3";

package vega;
option go_package = "code.vegaprotocol.io/vega/proto";

import "github.com/mwitkow/go-proto-validators/validator.proto";

import "proto/markets.proto";
import "proto/assets.proto";

message NetworkConfiguration {
  // Constrains minimum duration since submission (in seconds) when vote closing time is allowed to be set for a proposal.
  int64 minCloseInSeconds = 1;
  // Constrains maximum duration since submission (in seconds) when vote closing time is allowed to be set for a proposal.
  int64 maxCloseInSeconds = 2;

  // Constrains minimum duration since submission (in seconds) when enactment is allowed to be set for a proposal.
  int64 minEnactInSeconds = 3;
  // Constrains maximum duration since submission (in seconds) when enactment is allowed to be set for a proposal.
  int64 maxEnactInSeconds = 4;

  // Participation level required for any proposal to pass. Value from `0` to `1`.
  float requiredParticipation = 5;
  // Majority level required for any proposal to pass. Value from `0.5` to `1`.
  float requiredMajority = 6;
  // Minimum balance required for a party to be able to submit a new proposal. Value greater than `0` to `1`.
  float minProposerBalance = 7;
  // Minimum balance required for a party to be able to cast a vote. Value greater than `0` to `1`.
  float minVoterBalance = 8;

  // Scaling factors for all markets created via governance.
  ScalingFactors marginConfiguration = 9;

  // FeeFactors which are not set via proposal
  FeeFactorsConfiguration feeFactorsConfiguration = 10;
}

// FeeFactors set at the network level
message FeeFactorsConfiguration {
  // the infrastructure fee, needs to be a valid float
  string infrastructureFee = 1;
  // the maker fee, needs to be a valid float
  string makerFee = 2;
  // this is the liquidity fee, it needs to be a valid float
  string liquidityFee = 3;
}

message UpdateMarket {
  //TODO
}

// Future product configuration
message FutureProduct {
  // Future product maturity (ISO8601/RFC3339 timestamp)
  string maturity = 1  [(validator.field) = {string_not_empty : true}];
  // Product asset name
  string asset = 2  [(validator.field) = {string_not_empty : true}];
}

message InstrumentConfiguration {
  // Instrument name
  string name = 1 [(validator.field) = {string_not_empty : true}];
  // Instrument code
  string code = 2 [(validator.field) = {string_not_empty : true}];
  // Base security used as the reference
  string baseName = 3 [(validator.field) = {string_not_empty : true}];
  // Quote (secondary) security
  string quoteName = 4 [(validator.field) = {string_not_empty : true}];
  // Product specification
  oneof product {
    FutureProduct future = 100;

    //@TODO: more products
  }
}

message NewMarketConfiguration {
  // New market instrument configuration
  InstrumentConfiguration instrument = 1 [(validator.field) = {msg_exists: true}];
  // Decimal places used for the new market
  uint64 decimalPlaces = 2 [(validator.field) = {int_lt: 150}];
  // Optional new market meta data, tags
  repeated string metadata = 3;

  // for now, just specify a time for the opening auction to last
  int64 openingAuctionDuration = 4;

  // New market risk model parameters
  oneof riskParameters {
    // Simple risk model parameters, valid only if MODEL_SIMPLE is selected
    SimpleModelParams simple = 100;
    // Log normal risk model parameters, valid only if MODEL_LOG_NORMAL is selected
    LogNormalRiskModel logNormal = 101;
  }
  // Trading mode
  oneof tradingMode {
    ContinuousTrading continuous = 200;
    DiscreteTrading discrete = 201;
  }
}

message NewMarket {
  NewMarketConfiguration changes = 1 [(validator.field) = {msg_exists: true}];
}
message UpdateNetwork {
  NetworkConfiguration changes = 1 [(validator.field) = {msg_exists: true}];
}

// To be implemented
message NewAsset {
  AssetSource changes = 1 [(validator.field) = {msg_exists: true}];
}

message ProposalTerms {
  // Timestamp (Unix time in seconds) when voting closes for this proposal.
  // Constrained by `minCloseInSeconds` and `maxCloseInSeconds` network parameters.
  int64 closingTimestamp      = 1 [(validator.field) = {int_gt: 0}];
  // Timestamp (Unix time in seconds) when proposal gets enacted (if passed).
  // Constrained by `minEnactInSeconds` and `maxEnactInSeconds` network parameters.
  int64 enactmentTimestamp    = 2 [(validator.field) = {int_gt: 0}];

  int64 validationTimestamp = 3; //TODO: this should be moved into `NewAsset` definition.

  // Actual changes being proposed
  oneof change {
    // Proposal change for modifying an existing market on Vega.
    UpdateMarket  updateMarket  = 101;
    // Proposal change for creating new market on Vega.
    NewMarket     newMarket     = 102;
    // Proposal change for updating Vega network parameters.
    UpdateNetwork updateNetwork = 103;
    // Proposal change for creating new assets on Vega.
    NewAsset      newAsset      = 104;
  };
}

message GovernanceData {
  // Proposal
  Proposal proposal = 1;
  // All "yes" votes in favour of the proposal above.
  repeated Vote yes = 2;
  // All "no" votes against the proposal above.
  repeated Vote no = 3;

  // All latest YES votes by party (guaranteed to be unique)
  map<string, Vote> yesParty = 4;

  // All latest NO votes by party (unique)
  map<string, Vote> noParty = 5;
}

message Proposal {
  // Proposal state transition:
  // Open ->
  //   - Passed -> Enacted.
  //   - Passed -> Failed.
  //   - Declined
  // Rejected
  // Proposal can enter Failed state from any other state.
  enum State {
    // Default value, always invalid.
    STATE_UNSPECIFIED = 0;

    // Proposal enactment has failed - even though proposal has passed, its execusion could not be performed.
    STATE_FAILED = 1;

    // Proposal is open for voting.
    STATE_OPEN = 2;

    // Proposal has gained enough support to be executed.
    STATE_PASSED = 3;

    // Proposal wasn't accepted (proposal terms failed validation due to wrong configuration or failing to meet network requirements).
    STATE_REJECTED = 4;

    // Proposal didn't get enough votes (either failing to gain required participation or majority level).
    STATE_DECLINED = 5;

    STATE_ENACTED = 6;

    // waiting for validators validation of the proposal
    STATE_WAITING_FOR_NODE_VOTE = 7;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum ProposalState)
  }

  // Proposal unique identifier.
  string        ID        = 1;
  // Proposal reference.
  string        reference = 2;
  // Proposal author, identifier of the party submitting the proposal.
  string        partyID   = 3 [(validator.field) = {string_not_empty : true}];
  // Proposal state (see Proposal.State definition)
  State         state     = 4 [(validator.field) = {is_in_enum: true}];
  // Proposal timestamp for date and time (in nanoseconds) when proposal was submitted to the network.
  int64         timestamp = 5;
  // Proposal configuration and the actual change that is meant to be executed when proposal is enacted.
  ProposalTerms terms     = 6 [(validator.field) = {msg_exists: true}];

  // A reason for the current state of the proposal
  // this may be set in case of REJECTED and FAILED status
  ProposalError reason = 7;
}

// A list of possible error which could have happenned
// and the cause for an proposal being rejected of failed
enum ProposalError {
  // default value
  PROPOSAL_ERROR_UNSPECIFIED = 0;
  // the specified close time is too early base on network parameters
  PROPOSAL_ERROR_CLOSE_TIME_TOO_SOON = 1;
  // the specified close time is too late based on network parameters
  PROPOSAL_ERROR_CLOSE_TIME_TOO_LATE = 2;
  // the specified enact time is too early base on network parameters
  PROPOSAL_ERROR_ENACT_TIME_TOO_SOON = 3;
  // the specified enact time is too late based on network parameters
  PROPOSAL_ERROR_ENACT_TIME_TOO_LATE = 4;
  // the proposer for this proposal as insufficient token
  PROPOSAL_ERROR_INSUFFICIENT_TOKENS = 5;
  // the instrument quote name and base name were the same
  PROPOSAL_ERROR_INVALID_INSTRUMENT_SECURITY = 6;
  // the proposal has not product
  PROPOSAL_ERROR_NO_PRODUCT = 7;
  // the specified product is not supported
  PROPOSAL_ERROR_UNSUPPORTED_PRODUCT = 8;
  // invalid future maturity timestamp (expect RFC3339)
  PROPOSAL_ERROR_INVALID_FUTURE_PRODUCT_TIMESTAMP = 9;
  // the product maturity is past
  PROPOSAL_ERROR_PRODUCT_MATURITY_IS_PASSED = 10;
  // the proposal has not trading mode
  PROPOSAL_ERROR_NO_TRADING_MODE = 11;
  // the proposal has an unsupported trading mode
  PROPOSAL_ERROR_UNSUPPORTED_TRADING_MODE = 12;
  // the proposal failed node validation
  PROPOSAL_ERROR_NODE_VALIDATION_FAILED = 13;
  // a field is missing in a builtin asset source
  PROPOSAL_ERROR_MISSING_BUILTIN_ASSET_FIELD = 14;
  // the contract address is missing in the ERC20 asset source
  PROPOSAL_ERROR_MISSING_ERC20_CONTRACT_ADDRESS = 15;
  // the asset id refer to no assets in vega
  PROPOSAL_ERROR_INVALID_ASSET = 16;
  // proposal terms timestamps are not compatible (Validation < Closing < Enactment)
  PROPOSAL_ERROR_INCOMPATIBLE_TIMESTAMPS = 17;
}

message Vote {

  enum Value {
    // Default value, always invalid.
    VALUE_UNSPECIFIED = 0;

    // A vote against the proposal.
    VALUE_NO  = 1;

    // A vote in favour of the proposal.
    VALUE_YES = 2;

    // Note: If adding an enum value, add a matching entry in:
    //       - gateway/graphql/helpers_enum.go
    //       - gateway/graphql/schema.graphql (enum VoteValue)
  }

  // Voter's party identifier.
  string partyID    = 1 [(validator.field) = {string_not_empty : true}];
  // Actual vote.
  Value  value      = 2 [(validator.field) = {is_in_enum : true}];
  // Identifier of the proposal being voted on.
  string proposalID = 3 [(validator.field) = {string_not_empty : true}];
  // Vote timestamp for date and time (in nanoseconds) when vote was submitted to the network.
  int64  timestamp  = 4;
}
