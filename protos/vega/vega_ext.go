// vega_ext provides extra methods to the types generated by protobuf.

package vega

import (
	fmt "fmt"
	"strconv"
	"time"
)

const (
	systemOwner = "*"
	noMarket    = "!"
)

func (ad *AccountDetails) ID() string {
	idbuf := make([]byte, 256)
	marketID, partyID := noMarket, systemOwner
	if ad.MarketId != nil {
		marketID = *ad.MarketId
	}

	// market account
	if ad.Owner != nil {
		partyID = *ad.Owner
	}

	copy(idbuf, marketID)
	ln := len(marketID)
	copy(idbuf[ln:], partyID)
	ln += len(partyID)
	copy(idbuf[ln:], []byte(ad.AssetId))
	ln += len(ad.AssetId)
	idbuf[ln] = byte(ad.Type + 48)
	return string(idbuf[:ln+1])
}

// Float64Fee tries to parse the Fee (string) into a float64.
// If parsing fails 0 is returned.
func (l *LiquidityProvision) Float64Fee() float64 {
	v, err := strconv.ParseFloat(l.Fee, 64)
	if err != nil {
		return 0
	}
	return v
}

func (o *Order) IsLiquidityOrder() bool {
	return len(o.LiquidityProvisionId) > 0
}

// Create sets the creation time (CreatedAt) to t and returns the
// updated order.
func (o *Order) Create(t time.Time) *Order {
	o.CreatedAt = t.UnixNano()
	return o
}

// Update sets the modification time (UpdatedAt) to t and returns the
// updated order.
func (o *Order) Update(t time.Time) *Order {
	o.UpdatedAt = t.UnixNano()
	return o
}

// IsPersistent returns true if the order is persistent.
// A persistent order is a Limit type order that might be
// matched in the future.
func (o *Order) IsPersistent() bool {
	return (o.TimeInForce == Order_TIME_IN_FORCE_GTC ||
		o.TimeInForce == Order_TIME_IN_FORCE_GTT ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFN ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFA) &&
		o.Type == Order_TYPE_LIMIT &&
		o.Remaining > 0
}

func (o *Order) IsExpireable() bool {
	return (o.TimeInForce == Order_TIME_IN_FORCE_GFN ||
		o.TimeInForce == Order_TIME_IN_FORCE_GTT ||
		o.TimeInForce == Order_TIME_IN_FORCE_GFA) &&
		o.ExpiresAt > 0
}

// IsFinished returns true if an order
// is in any state different to ACTIVE and PARKED
// Basically any order which is never gonna
// trade anymore.
func (o *Order) IsFinished() bool {
	return o.Status != Order_STATUS_ACTIVE && o.Status != Order_STATUS_PARKED
}

func (o *Order) HasTraded() bool {
	return o.Size != o.Remaining
}

func (t *Trade) SetIDs(aggressive, passive *Order, idx int) {
	t.Id = fmt.Sprintf("%s-%010d", aggressive.Id, idx)
	if aggressive.Side == Side_SIDE_BUY {
		t.BuyOrder = aggressive.Id
		t.SellOrder = passive.Id
		return
	}
	t.SellOrder = aggressive.Id
	t.BuyOrder = passive.Id
}

func (DispatchMetric) GetEnums() map[int32]string {
	return DispatchMetric_name
}

func (Side) GetEnums() map[int32]string {
	return Side_name
}

func (Asset_Status) GetEnums() map[int32]string {
	return Asset_Status_name
}

func (Market_TradingMode) GetEnums() map[int32]string {
	return Market_TradingMode_name
}

func (Market_State) GetEnums() map[int32]string {
	return Market_State_name
}

func (NodeStatus) GetEnums() map[int32]string {
	return NodeStatus_name
}

func (ValidatorNodeStatus) GetEnums() map[int32]string {
	return ValidatorNodeStatus_name
}

func (Deposit_Status) GetEnums() map[int32]string {
	return Deposit_Status_name
}

func (Withdrawal_Status) GetEnums() map[int32]string {
	return Withdrawal_Status_name
}

func (Proposal_State) GetEnums() map[int32]string {
	return Proposal_State_name
}

func (ProposalError) GetEnums() map[int32]string {
	return ProposalError_name
}

func (Vote_Value) GetEnums() map[int32]string {
	return Vote_Value_name
}

func (PositionStatus) GetEnums() map[int32]string {
	return PositionStatus_name
}

func (DataSourceSpec_Status) GetEnums() map[int32]string {
	return DataSourceSpec_Status_name
}

func (LiquidityProvision_Status) GetEnums() map[int32]string {
	return LiquidityProvision_Status_name
}

func (TransferType) GetEnums() map[int32]string {
	return TransferType_name
}

func (MarginMode) GetEnums() map[int32]string {
	return MarginMode_name
}

func (StopOrder_ExpiryStrategy) GetEnums() map[int32]string {
	return StopOrder_ExpiryStrategy_name
}

func (StopOrder_TriggerDirection) GetEnums() map[int32]string {
	return StopOrder_TriggerDirection_name
}

func (StopOrder_Status) GetEnums() map[int32]string {
	return StopOrder_Status_name
}

func (StopOrder_RejectionReason) GetEnums() map[int32]string {
	return StopOrder_RejectionReason_name
}

func (CompositePriceType) GetEnums() map[int32]string {
	return CompositePriceType_name
}

func (AuctionTrigger) GetEnums() map[int32]string {
	return AuctionTrigger_name
}
